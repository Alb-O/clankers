use serde::{Deserialize, Serialize};
use thiserror::Error;

use super::CompletionError;
use crate::OneOrMany;

/// A useful trait to help convert `clankers::completion::Message` to your own message type.
///
/// Particularly useful if you don't want to create a free-standing function as
/// when trying to use `TryFrom<T>`, you would normally run into the orphan rule as Vec is
/// technically considered a foreign type (it's owned by stdlib).
pub trait ConvertMessage: Sized + Send + Sync {
	type Error: std::error::Error + Send;

	fn convert_from_message(message: Message) -> Result<Vec<Self>, Self::Error>;
}

/// A message represents a run of input (user) and output (assistant).
/// Each message type (based on it's `role`) can contain a atleast one bit of content such as text,
///  images, audio, documents, or tool related information. While each message type can contain
///  multiple content, most often, you'll only see one content type per message
///  (an image w/ a description, etc).
///
/// Each provider is responsible with converting the generic message into it's provider specific
///  type using `From` or `TryFrom` traits. Since not every provider supports every feature, the
///  conversion can be lossy (providing an image might be discarded for a non-image supporting
///  provider) though the message being converted back and forth should always be the same.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(tag = "role", rename_all = "lowercase")]
pub enum Message {
	/// User message containing one or more content types defined by `UserContent`.
	User { content: OneOrMany<UserContent> },

	/// Assistant message containing one or more content types defined by `AssistantContent`.
	Assistant {
		id: Option<String>,
		content: OneOrMany<AssistantContent>,
	},
}

/// Describes the content of a message, which can be text, a tool result, an image, audio, or
///  a document. Dependent on provider supporting the content type. Multimedia content is generally
///  base64 (defined by it's format) encoded but additionally supports urls (for some providers).
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum UserContent {
	Text(Text),
	ToolResult(ToolResult),
	Image(Image),
	Audio(Audio),
	Video(Video),
	Document(Document),
}

/// Describes responses from a provider which is either text or a tool call.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(untagged)]
pub enum AssistantContent {
	Text(Text),
	ToolCall(ToolCall),
	Reasoning(Reasoning),
	Image(Image),
}

#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[non_exhaustive]
pub struct Reasoning {
	pub id: Option<String>,
	pub reasoning: Vec<String>,
	/// Optional cryptographic signature for the reasoning content.
	///
	/// This field is used by some providers (e.g., Anthropic) to provide a signature
	/// that can verify the authenticity and integrity of the reasoning output. When present,
	/// it allows verification that the reasoning content was actually generated by the model
	/// and has not been tampered with.
	///
	/// This is an optional, provider-specific feature and will be `None` for providers
	/// that don't support reasoning signatures.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub signature: Option<String>,
}

impl Reasoning {
	/// Create a new reasoning item from a single item
	pub fn new(input: &str) -> Self {
		Self {
			id: None,
			reasoning: vec![input.to_string()],
			signature: None,
		}
	}

	pub fn optional_id(mut self, id: Option<String>) -> Self {
		self.id = id;
		self
	}
	pub fn with_id(mut self, id: String) -> Self {
		self.id = Some(id);
		self
	}

	pub fn with_signature(mut self, signature: Option<String>) -> Self {
		self.signature = signature;
		self
	}

	pub fn multi(input: Vec<String>) -> Self {
		Self {
			id: None,
			reasoning: input,
			signature: None,
		}
	}
}

/// Tool result content containing information about a tool call and it's resulting content.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct ToolResult {
	pub id: String,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub call_id: Option<String>,
	pub content: OneOrMany<ToolResultContent>,
}

/// Describes the content of a tool result, which can be text or an image.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(tag = "type", rename_all = "lowercase")]
pub enum ToolResultContent {
	Text(Text),
	Image(Image),
}

/// Describes a tool call with an id and function to call, generally produced by a provider.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct ToolCall {
	pub id: String,
	pub call_id: Option<String>,
	pub function: ToolFunction,
	/// Optional cryptographic signature for the tool call.
	///
	/// This field is used by some providers (e.g., Google) to provide a signature
	/// that can verify the authenticity and integrity of the tool call. When present,
	/// it allows verification that the tool call was actually generated by the model
	/// and has not been tampered with.
	///
	/// This is an optional, provider-specific feature and will be `None` for providers
	/// that don't support tool call signatures.
	pub signature: Option<String>,
	/// Additional provider-specific parameters to be sent to the completion model provider
	pub additional_params: Option<serde_json::Value>,
}

impl ToolCall {
	pub fn new(id: String, function: ToolFunction) -> Self {
		Self {
			id,
			call_id: None,
			function,
			signature: None,
			additional_params: None,
		}
	}

	pub fn with_call_id(mut self, call_id: String) -> Self {
		self.call_id = Some(call_id);
		self
	}

	pub fn with_signature(mut self, signature: Option<String>) -> Self {
		self.signature = signature;
		self
	}

	pub fn with_additional_params(mut self, additional_params: Option<serde_json::Value>) -> Self {
		self.additional_params = additional_params;
		self
	}
}

/// Describes a tool function to call with a name and arguments, generally produced by a provider.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct ToolFunction {
	pub name: String,
	pub arguments: serde_json::Value,
}

impl ToolFunction {
	pub fn new(name: String, arguments: serde_json::Value) -> Self {
		Self { name, arguments }
	}
}

/// Basic text content.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct Text {
	pub text: String,
}

impl Text {
	pub fn text(&self) -> &str {
		&self.text
	}
}

impl std::fmt::Display for Text {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		let Self { text } = self;
		write!(f, "{text}")
	}
}

/// Image content containing image data and metadata about it.
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct Image {
	pub data: DocumentSourceKind,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub media_type: Option<ImageMediaType>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub detail: Option<ImageDetail>,
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

impl Image {
	pub fn try_into_url(self) -> Result<String, MessageError> {
		match self.data {
			DocumentSourceKind::Url(url) => Ok(url),
			DocumentSourceKind::Base64(data) => {
				let Some(media_type) = self.media_type else {
					return Err(MessageError::ConversionError(
						"A media type is required to create a valid base64-encoded image URL"
							.to_string(),
					));
				};

				Ok(format!(
					"data:image/{ty};base64,{data}",
					ty = media_type.to_mime_type()
				))
			}
			unknown => Err(MessageError::ConversionError(format!(
				"Tried to convert unknown type to a URL: {unknown:?}"
			))),
		}
	}
}

/// The kind of image source (to be used).
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq, Default)]
#[serde(tag = "type", content = "value", rename_all = "camelCase")]
#[non_exhaustive]
pub enum DocumentSourceKind {
	/// A file URL/URI.
	Url(String),
	/// A base-64 encoded string.
	Base64(String),
	/// Raw bytes
	Raw(Vec<u8>),
	/// A string (or a string literal).
	String(String),
	#[default]
	/// An unknown file source (there's nothing there).
	Unknown,
}

impl DocumentSourceKind {
	pub fn url(url: &str) -> Self {
		Self::Url(url.to_string())
	}

	pub fn base64(base64_string: &str) -> Self {
		Self::Base64(base64_string.to_string())
	}

	pub fn raw(bytes: impl Into<Vec<u8>>) -> Self {
		Self::Raw(bytes.into())
	}

	pub fn string(input: &str) -> Self {
		Self::String(input.into())
	}

	pub fn unknown() -> Self {
		Self::Unknown
	}

	pub fn try_into_inner(self) -> Option<String> {
		match self {
			Self::Url(s) | Self::Base64(s) => Some(s),
			_ => None,
		}
	}
}

impl std::fmt::Display for DocumentSourceKind {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		match self {
			Self::Url(string) => write!(f, "{string}"),
			Self::Base64(string) => write!(f, "{string}"),
			Self::String(string) => write!(f, "{string}"),
			Self::Raw(_) => write!(f, "<binary data>"),
			Self::Unknown => write!(f, "<unknown>"),
		}
	}
}

/// Audio content containing audio data and metadata about it.
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct Audio {
	pub data: DocumentSourceKind,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub media_type: Option<AudioMediaType>,
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

/// Video content containing video data and metadata about it.
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct Video {
	pub data: DocumentSourceKind,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub media_type: Option<VideoMediaType>,
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

/// Document content containing document data and metadata about it.
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
pub struct Document {
	pub data: DocumentSourceKind,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub media_type: Option<DocumentMediaType>,
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

/// Describes the format of the content, which can be base64 or string.
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ContentFormat {
	#[default]
	Base64,
	String,
	Url,
}

/// Helper enum that tracks the media type of the content.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
pub enum MediaType {
	Image(ImageMediaType),
	Audio(AudioMediaType),
	Document(DocumentMediaType),
	Video(VideoMediaType),
}

/// Describes the image media type of the content. Not every provider supports every media type.
/// Convertible to and from MIME type strings.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ImageMediaType {
	JPEG,
	PNG,
	GIF,
	WEBP,
	HEIC,
	HEIF,
	SVG,
}

/// Describes the document media type of the content. Not every provider supports every media type.
/// Includes also programming languages as document types for providers who support code running.
/// Convertible to and from MIME type strings.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum DocumentMediaType {
	PDF,
	TXT,
	RTF,
	HTML,
	CSS,
	MARKDOWN,
	CSV,
	XML,
	Javascript,
	Python,
}

impl DocumentMediaType {
	pub fn is_code(&self) -> bool {
		matches!(self, Self::Javascript | Self::Python)
	}
}

/// Describes the audio media type of the content. Not every provider supports every media type.
/// Convertible to and from MIME type strings.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum AudioMediaType {
	WAV,
	MP3,
	AIFF,
	AAC,
	OGG,
	FLAC,
}

/// Describes the video media type of the content. Not every provider supports every media type.
/// Convertible to and from MIME type strings.
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum VideoMediaType {
	AVI,
	MP4,
	MPEG,
}

/// Describes the detail of the image content, which can be low, high, or auto (open-ai specific).
#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum ImageDetail {
	Low,
	High,
	#[default]
	Auto,
}

/// Trait for converting between MIME types and media types.
pub trait MimeType {
	fn from_mime_type(mime_type: &str) -> Option<Self>
	where
		Self: Sized;
	fn to_mime_type(&self) -> &'static str;
}

#[derive(Default, Clone, Debug, Deserialize, Serialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum ToolChoice {
	#[default]
	Auto,
	None,
	Required,
	Specific {
		function_names: Vec<String>,
	},
}

/// Error type to represent issues with converting messages to and from specific provider messages.
#[derive(Debug, Error)]
pub enum MessageError {
	#[error("Message conversion error: {0}")]
	ConversionError(String),
}

impl From<MessageError> for CompletionError {
	fn from(error: MessageError) -> Self {
		CompletionError::RequestError(error.into())
	}
}
