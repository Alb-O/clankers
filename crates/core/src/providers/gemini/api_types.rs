use std::collections::HashMap;
use std::convert::Infallible;
use std::str::FromStr;

use serde::{Deserialize, Serialize};
use serde_json::{Value, json};

use crate::completion::{CompletionError, GetTokenUsage};
use crate::message::{
	DocumentSourceKind, ImageMediaType, MessageError, MimeType, {self},
};
use crate::telemetry::ProviderResponseExt;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum ExecutionLanguage {
	/// Unspecified language. This value should not be used.
	LanguageUnspecified,
	/// Python >= 3.10, with numpy and simply available.
	Python,
}

/// Code generated by the model that is meant to be executed, and the result returned to the model.
/// Only generated when using the CodeExecution tool, in which the code will be automatically executed,
/// and a corresponding CodeExecutionResult will also be generated.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
pub struct ExecutableCode {
	/// Programming language of the code.
	pub language: ExecutionLanguage,
	/// The code to be executed.
	pub code: String,
}
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub struct CodeExecutionResult {
	/// Outcome of the code execution.
	pub outcome: CodeExecutionOutcome,
	/// Contains stdout when code execution is successful, stderr or other description otherwise.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub output: Option<String>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum CodeExecutionOutcome {
	/// Unspecified status. This value should not be used.
	#[serde(rename = "OUTCOME_UNSPECIFIED")]
	Unspecified,
	/// Code execution completed successfully.
	#[serde(rename = "OUTCOME_OK")]
	Ok,
	/// Code execution finished but with a failure. stderr should contain the reason.
	#[serde(rename = "OUTCOME_FAILED")]
	Failed,
	/// Code execution ran for too long, and was cancelled. There may or may not be a partial output present.
	#[serde(rename = "OUTCOME_DEADLINE_EXCEEDED")]
	DeadlineExceeded,
}

#[derive(Debug, Deserialize, Serialize, Default)]
#[serde(rename_all = "camelCase")]
pub struct AdditionalParameters {
	/// Change your Gemini request configuration.
	pub generation_config: Option<GenerationConfig>,
	/// Any additional parameters that you want.
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

impl AdditionalParameters {
	pub fn with_config(mut self, cfg: GenerationConfig) -> Self {
		self.generation_config = Some(cfg);
		self
	}

	pub fn with_params(mut self, params: serde_json::Value) -> Self {
		self.additional_params = Some(params);
		self
	}
}

/// Response from the model supporting multiple candidate responses.
/// Safety ratings and content filtering are reported for both prompt in GenerateContentResponse.prompt_feedback
/// and for each candidate in finishReason and in safetyRatings.
/// The API:
///     - Returns either all requested candidates or none of them
///     - Returns no candidates at all only if there was something wrong with the prompt (check promptFeedback)
///     - Reports feedback on each candidate in finishReason and safetyRatings.
#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct GenerateContentResponse {
	pub response_id: String,
	/// Candidate responses from the model.
	pub candidates: Vec<ContentCandidate>,
	/// Returns the prompt's feedback related to the content filters.
	pub prompt_feedback: Option<PromptFeedback>,
	/// Output only. Metadata on the generation requests' token usage.
	pub usage_metadata: Option<UsageMetadata>,
	pub model_version: Option<String>,
}

impl ProviderResponseExt for GenerateContentResponse {
	type OutputMessage = ContentCandidate;
	type Usage = UsageMetadata;

	fn get_response_id(&self) -> Option<String> {
		Some(self.response_id.clone())
	}

	fn get_response_model_name(&self) -> Option<String> {
		None
	}

	fn get_output_messages(&self) -> Vec<Self::OutputMessage> {
		self.candidates.clone()
	}

	fn get_text_response(&self) -> Option<String> {
		let str = self
			.candidates
			.iter()
			.filter_map(|x| {
				let content = x.content.as_ref()?;
				if content.role.as_ref().is_none_or(|y| y != &Role::Model) {
					return None;
				}

				let res = content
					.parts
					.iter()
					.filter_map(|part| {
						if let PartKind::Text(ref str) = part.part {
							Some(str.to_owned())
						} else {
							None
						}
					})
					.collect::<Vec<String>>()
					.join("\n");

				Some(res)
			})
			.collect::<Vec<String>>()
			.join("\n");

		if str.is_empty() { None } else { Some(str) }
	}

	fn get_usage(&self) -> Option<Self::Usage> {
		self.usage_metadata.clone()
	}
}

/// A response candidate generated from the model.
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ContentCandidate {
	/// Output only. Generated content returned from the model.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub content: Option<Content>,
	/// Optional. Output only. The reason why the model stopped generating tokens.
	/// If empty, the model has not stopped generating tokens.
	pub finish_reason: Option<FinishReason>,
	/// List of ratings for the safety of a response candidate.
	/// There is at most one rating per category.
	pub safety_ratings: Option<Vec<SafetyRating>>,
	/// Output only. Citation information for model-generated candidate.
	/// This field may be populated with recitation information for any text included in the content.
	/// These are passages that are "recited" from copyrighted material in the foundational LLM's training data.
	pub citation_metadata: Option<CitationMetadata>,
	/// Output only. Token count for this candidate.
	pub token_count: Option<i32>,
	/// Output only.
	pub avg_logprobs: Option<f64>,
	/// Output only. Log-likelihood scores for the response tokens and top tokens
	pub logprobs_result: Option<LogprobsResult>,
	/// Output only. Index of the candidate in the list of response candidates.
	pub index: Option<i32>,
	/// Output only. Additional information about why the model stopped generating tokens.
	pub finish_message: Option<String>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct Content {
	/// Ordered Parts that constitute a single message. Parts may have different MIME types.
	#[serde(default)]
	pub parts: Vec<Part>,
	/// The producer of the content. Must be either 'user' or 'model'.
	/// Useful to set for multi-turn conversations, otherwise can be left blank or unset.
	pub role: Option<Role>,
}

impl TryFrom<message::Message> for Content {
	type Error = message::MessageError;

	fn try_from(msg: message::Message) -> Result<Self, Self::Error> {
		Ok(match msg {
			message::Message::User { content } => Content {
				parts: content
					.into_iter()
					.map(|c| c.try_into())
					.collect::<Result<Vec<_>, _>>()?,
				role: Some(Role::User),
			},
			message::Message::Assistant { content, .. } => Content {
				role: Some(Role::Model),
				parts: content
					.into_iter()
					.map(|content| content.try_into())
					.collect::<Result<Vec<_>, _>>()?,
			},
		})
	}
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum Role {
	User,
	Model,
}

#[derive(Debug, Default, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Part {
	/// whether or not the part is a reasoning/thinking text or not
	#[serde(skip_serializing_if = "Option::is_none")]
	pub thought: Option<bool>,
	/// an opaque sig for the thought so it can be reused - is a base64 string
	#[serde(skip_serializing_if = "Option::is_none")]
	pub thought_signature: Option<String>,
	#[serde(flatten)]
	pub part: PartKind,
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<Value>,
}

/// A datatype containing media that is part of a multi-part [Content] message.
/// A Part consists of data which has an associated datatype. A Part can only contain one of the accepted types in Part.data.
/// A Part must have a fixed IANA MIME type identifying the type and subtype of the media if the inlineData field is filled with raw bytes.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub enum PartKind {
	Text(String),
	InlineData(Blob),
	FunctionCall(FunctionCall),
	FunctionResponse(FunctionResponse),
	FileData(FileData),
	ExecutableCode(ExecutableCode),
	CodeExecutionResult(CodeExecutionResult),
}

// This default instance is primarily so we can easily fill in the optional fields of `Part`
// So this instance for `PartKind` (and the allocation it would cause) should be optimized away
impl Default for PartKind {
	fn default() -> Self {
		Self::Text(String::new())
	}
}

impl From<String> for Part {
	fn from(text: String) -> Self {
		Self {
			thought: Some(false),
			thought_signature: None,
			part: PartKind::Text(text),
			additional_params: None,
		}
	}
}

impl From<&str> for Part {
	fn from(text: &str) -> Self {
		Self::from(text.to_string())
	}
}

impl FromStr for Part {
	type Err = Infallible;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		Ok(s.into())
	}
}

impl TryFrom<(ImageMediaType, DocumentSourceKind)> for PartKind {
	type Error = message::MessageError;
	fn try_from(
		(mime_type, doc_src): (ImageMediaType, DocumentSourceKind),
	) -> Result<Self, Self::Error> {
		let mime_type = mime_type.to_mime_type().to_string();
		let part = match doc_src {
			DocumentSourceKind::Url(url) => PartKind::FileData(FileData {
				mime_type: Some(mime_type),
				file_uri: url,
			}),
			DocumentSourceKind::Base64(data) | DocumentSourceKind::String(data) => {
				PartKind::InlineData(Blob { mime_type, data })
			}
			DocumentSourceKind::Raw(_) => {
				return Err(message::MessageError::ConversionError(
					"Raw files not supported, encode as base64 first".into(),
				));
			}
			DocumentSourceKind::Unknown => {
				return Err(message::MessageError::ConversionError(
					"Can't convert an unknown document source".to_string(),
				));
			}
		};

		Ok(part)
	}
}

impl TryFrom<message::UserContent> for Part {
	type Error = message::MessageError;

	fn try_from(content: message::UserContent) -> Result<Self, Self::Error> {
		match content {
			message::UserContent::Text(message::Text { text }) => Ok(Part {
				thought: Some(false),
				thought_signature: None,
				part: PartKind::Text(text),
				additional_params: None,
			}),
			message::UserContent::ToolResult(message::ToolResult { id, content, .. }) => {
				let mut response_json: Option<serde_json::Value> = None;
				let mut parts: Vec<FunctionResponsePart> = Vec::new();

				for item in content.iter() {
					match item {
						message::ToolResultContent::Text(text) => {
							let result: serde_json::Value = serde_json::from_str(&text.text)
								.unwrap_or_else(|error| {
									tracing::trace!(
										?error,
										"Tool result is not a valid JSON, treat it as normal string"
									);
									json!(&text.text)
								});

							response_json = Some(match response_json {
								Some(mut existing) => {
									if let serde_json::Value::Object(ref mut map) = existing {
										map.insert("text".to_string(), result);
									}
									existing
								}
								None => json!({ "result": result }),
							});
						}
						message::ToolResultContent::Image(image) => {
							let part = match &image.data {
								DocumentSourceKind::Base64(b64) => {
									let mime_type = image
										.media_type
										.as_ref()
										.ok_or(message::MessageError::ConversionError(
											"Image media type is required for Gemini tool results"
												.to_string(),
										))?
										.to_mime_type();

									FunctionResponsePart {
										inline_data: Some(FunctionResponseInlineData {
											mime_type: mime_type.to_string(),
											data: b64.clone(),
											display_name: None,
										}),
										file_data: None,
									}
								}
								DocumentSourceKind::Url(url) => {
									let mime_type = image
										.media_type
										.as_ref()
										.map(|mt| mt.to_mime_type().to_string());

									FunctionResponsePart {
										inline_data: None,
										file_data: Some(FileData {
											mime_type,
											file_uri: url.clone(),
										}),
									}
								}
								_ => {
									return Err(message::MessageError::ConversionError(
										"Unsupported image source kind for tool results"
											.to_string(),
									));
								}
							};
							parts.push(part);
						}
					}
				}

				Ok(Part {
					thought: Some(false),
					thought_signature: None,
					part: PartKind::FunctionResponse(FunctionResponse {
						name: id,
						response: response_json,
						parts: if parts.is_empty() { None } else { Some(parts) },
					}),
					additional_params: None,
				})
			}
			message::UserContent::Image(message::Image {
				data, media_type, ..
			}) => match media_type {
				Some(media_type) => match media_type {
					message::ImageMediaType::JPEG
					| message::ImageMediaType::PNG
					| message::ImageMediaType::WEBP
					| message::ImageMediaType::HEIC
					| message::ImageMediaType::HEIF => {
						let part = PartKind::try_from((media_type, data))?;
						Ok(Part {
							thought: Some(false),
							thought_signature: None,
							part,
							additional_params: None,
						})
					}
					_ => Err(message::MessageError::ConversionError(format!(
						"Unsupported image media type {media_type:?}"
					))),
				},
				None => Err(message::MessageError::ConversionError(
					"Media type for image is required for Gemini".to_string(),
				)),
			},
			message::UserContent::Document(message::Document {
				data, media_type, ..
			}) => {
				let Some(media_type) = media_type else {
					return Err(MessageError::ConversionError(
						"A mime type is required for document inputs to Gemini".to_string(),
					));
				};

				if !media_type.is_code() {
					let mime_type = media_type.to_mime_type().to_string();

					let part = match data {
						DocumentSourceKind::Url(file_uri) => PartKind::FileData(FileData {
							mime_type: Some(mime_type),
							file_uri,
						}),
						DocumentSourceKind::Base64(data) | DocumentSourceKind::String(data) => {
							PartKind::InlineData(Blob { mime_type, data })
						}
						DocumentSourceKind::Raw(_) => {
							return Err(message::MessageError::ConversionError(
								"Raw files not supported, encode as base64 first".into(),
							));
						}
						_ => {
							return Err(message::MessageError::ConversionError(
								"Document has no body".to_string(),
							));
						}
					};

					Ok(Part {
						thought: Some(false),
						part,
						..Default::default()
					})
				} else {
					Err(message::MessageError::ConversionError(format!(
						"Unsupported document media type {media_type:?}"
					)))
				}
			}

			message::UserContent::Audio(message::Audio {
				data, media_type, ..
			}) => {
				let Some(media_type) = media_type else {
					return Err(MessageError::ConversionError(
						"A mime type is required for audio inputs to Gemini".to_string(),
					));
				};

				let mime_type = media_type.to_mime_type().to_string();

				let part = match data {
					DocumentSourceKind::Base64(data) => {
						PartKind::InlineData(Blob { data, mime_type })
					}

					DocumentSourceKind::Url(file_uri) => PartKind::FileData(FileData {
						mime_type: Some(mime_type),
						file_uri,
					}),
					DocumentSourceKind::String(_) => {
						return Err(message::MessageError::ConversionError(
							"Strings cannot be used as audio files!".into(),
						));
					}
					DocumentSourceKind::Raw(_) => {
						return Err(message::MessageError::ConversionError(
							"Raw files not supported, encode as base64 first".into(),
						));
					}
					DocumentSourceKind::Unknown => {
						return Err(message::MessageError::ConversionError(
							"Content has no body".to_string(),
						));
					}
				};

				Ok(Part {
					thought: Some(false),
					part,
					..Default::default()
				})
			}
			message::UserContent::Video(message::Video {
				data,
				media_type,
				additional_params,
				..
			}) => {
				let mime_type = media_type.map(|media_ty| media_ty.to_mime_type().to_string());

				let part = match data {
					DocumentSourceKind::Url(file_uri) => {
						if file_uri.starts_with("https://www.youtube.com") {
							PartKind::FileData(FileData {
								mime_type,
								file_uri,
							})
						} else {
							if mime_type.is_none() {
								return Err(MessageError::ConversionError(
                                    "A mime type is required for non-Youtube video file inputs to Gemini"
                                        .to_string(),
                                ));
							}

							PartKind::FileData(FileData {
								mime_type,
								file_uri,
							})
						}
					}
					DocumentSourceKind::Base64(data) => {
						let Some(mime_type) = mime_type else {
							return Err(MessageError::ConversionError(
								"A media type is expected for base64 encoded strings".to_string(),
							));
						};
						PartKind::InlineData(Blob { mime_type, data })
					}
					DocumentSourceKind::String(_) => {
						return Err(message::MessageError::ConversionError(
							"Strings cannot be used as audio files!".into(),
						));
					}
					DocumentSourceKind::Raw(_) => {
						return Err(message::MessageError::ConversionError(
							"Raw file data not supported, encode as base64 first".into(),
						));
					}
					DocumentSourceKind::Unknown => {
						return Err(message::MessageError::ConversionError(
							"Media type for video is required for Gemini".to_string(),
						));
					}
				};

				Ok(Part {
					thought: Some(false),
					thought_signature: None,
					part,
					additional_params,
				})
			}
		}
	}
}

impl TryFrom<message::AssistantContent> for Part {
	type Error = message::MessageError;

	fn try_from(content: message::AssistantContent) -> Result<Self, Self::Error> {
		match content {
			message::AssistantContent::Text(message::Text { text }) => Ok(text.into()),
			message::AssistantContent::Image(message::Image {
				data, media_type, ..
			}) => match media_type {
				Some(media_type) => match media_type {
					message::ImageMediaType::JPEG
					| message::ImageMediaType::PNG
					| message::ImageMediaType::WEBP
					| message::ImageMediaType::HEIC
					| message::ImageMediaType::HEIF => {
						let part = PartKind::try_from((media_type, data))?;
						Ok(Part {
							thought: Some(false),
							thought_signature: None,
							part,
							additional_params: None,
						})
					}
					_ => Err(message::MessageError::ConversionError(format!(
						"Unsupported image media type {media_type:?}"
					))),
				},
				None => Err(message::MessageError::ConversionError(
					"Media type for image is required for Gemini".to_string(),
				)),
			},
			message::AssistantContent::ToolCall(tool_call) => Ok(tool_call.into()),
			message::AssistantContent::Reasoning(message::Reasoning { reasoning, .. }) => {
				Ok(Part {
					thought: Some(true),
					thought_signature: None,
					part: PartKind::Text(
						reasoning.first().cloned().unwrap_or_else(|| "".to_string()),
					),
					additional_params: None,
				})
			}
		}
	}
}

impl From<message::ToolCall> for Part {
	fn from(tool_call: message::ToolCall) -> Self {
		Self {
			thought: Some(false),
			thought_signature: tool_call.signature,
			part: PartKind::FunctionCall(FunctionCall {
				name: tool_call.function.name,
				args: tool_call.function.arguments,
			}),
			additional_params: None,
		}
	}
}

/// Raw media bytes.
/// Text should not be sent as raw bytes, use the 'text' field.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct Blob {
	/// The IANA standard MIME type of the source data. Examples: - image/png - image/jpeg
	/// If an unsupported MIME type is provided, an error will be returned.
	pub mime_type: String,
	/// Raw bytes for media formats. A base64-encoded string.
	pub data: String,
}

/// A predicted FunctionCall returned from the model that contains a string representing the
/// FunctionDeclaration.name with the arguments and their values.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
pub struct FunctionCall {
	/// Required. The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores
	/// and dashes, with a maximum length of 63.
	pub name: String,
	/// Optional. The function parameters and values in JSON object format.
	pub args: serde_json::Value,
}

impl From<message::ToolCall> for FunctionCall {
	fn from(tool_call: message::ToolCall) -> Self {
		Self {
			name: tool_call.function.name,
			args: tool_call.function.arguments,
		}
	}
}

/// The result output from a FunctionCall that contains a string representing the FunctionDeclaration.name
/// and a structured JSON object containing any output from the function is used as context to the model.
/// This should contain the result of aFunctionCall made based on model prediction.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
pub struct FunctionResponse {
	/// The name of the function to call. Must be a-z, A-Z, 0-9, or contain underscores and dashes,
	/// with a maximum length of 63.
	pub name: String,
	/// The function response in JSON object format.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub response: Option<serde_json::Value>,
	/// Multimodal parts for the function response (e.g., images).
	#[serde(skip_serializing_if = "Option::is_none")]
	pub parts: Option<Vec<FunctionResponsePart>>,
}

/// A part of a multimodal function response.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionResponsePart {
	/// Inline data containing base64-encoded media content.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub inline_data: Option<FunctionResponseInlineData>,
	/// File data containing a URI reference.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub file_data: Option<FileData>,
}

/// Inline data for function response parts.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FunctionResponseInlineData {
	/// The IANA standard MIME type of the source data.
	pub mime_type: String,
	/// Raw bytes for media formats. A base64-encoded string.
	pub data: String,
	/// Optional display name for the content.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub display_name: Option<String>,
}

/// URI based data.
#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "camelCase")]
pub struct FileData {
	/// Optional. The IANA standard MIME type of the source data.
	pub mime_type: Option<String>,
	/// Required. URI.
	pub file_uri: String,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
pub struct SafetyRating {
	pub category: HarmCategory,
	pub probability: HarmProbability,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum HarmProbability {
	HarmProbabilityUnspecified,
	Negligible,
	Low,
	Medium,
	High,
}

#[derive(Debug, Deserialize, Serialize, Clone, PartialEq)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum HarmCategory {
	HarmCategoryUnspecified,
	HarmCategoryDerogatory,
	HarmCategoryToxicity,
	HarmCategoryViolence,
	HarmCategorySexually,
	HarmCategoryMedical,
	HarmCategoryDangerous,
	HarmCategoryHarassment,
	HarmCategoryHateSpeech,
	HarmCategorySexuallyExplicit,
	HarmCategoryDangerousContent,
	HarmCategoryCivicIntegrity,
}

#[derive(Debug, Deserialize, Clone, Default, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UsageMetadata {
	pub prompt_token_count: i32,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub cached_content_token_count: Option<i32>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub candidates_token_count: Option<i32>,
	pub total_token_count: i32,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub thoughts_token_count: Option<i32>,
}

impl std::fmt::Display for UsageMetadata {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		write!(
			f,
			"Prompt token count: {}\nCached content token count: {}\nCandidates token count: {}\nTotal token count: {}",
			self.prompt_token_count,
			match self.cached_content_token_count {
				Some(count) => count.to_string(),
				None => "n/a".to_string(),
			},
			match self.candidates_token_count {
				Some(count) => count.to_string(),
				None => "n/a".to_string(),
			},
			self.total_token_count
		)
	}
}

impl GetTokenUsage for UsageMetadata {
	fn token_usage(&self) -> Option<crate::completion::Usage> {
		let mut usage = crate::completion::Usage::new();

		usage.input_tokens = self.prompt_token_count as u64;
		usage.output_tokens = (self.cached_content_token_count.unwrap_or_default()
			+ self.candidates_token_count.unwrap_or_default()
			+ self.thoughts_token_count.unwrap_or_default()) as u64;
		usage.total_tokens = usage.input_tokens + usage.output_tokens;

		Some(usage)
	}
}

/// A set of the feedback metadata the prompt specified in [GenerateContentRequest.contents](GenerateContentRequest).
#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct PromptFeedback {
	/// Optional. If set, the prompt was blocked and no candidates are returned. Rephrase the prompt.
	pub block_reason: Option<BlockReason>,
	/// Ratings for safety of the prompt. There is at most one rating per category.
	pub safety_ratings: Option<Vec<SafetyRating>>,
}

/// Reason why a prompt was blocked by the model
#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum BlockReason {
	/// Default value. This value is unused.
	BlockReasonUnspecified,
	/// Prompt was blocked due to safety reasons. Inspect safetyRatings to understand which safety category blocked it.
	Safety,
	/// Prompt was blocked due to unknown reasons.
	Other,
	/// Prompt was blocked due to the terms which are included from the terminology blocklist.
	Blocklist,
	/// Prompt was blocked due to prohibited content.
	ProhibitedContent,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum FinishReason {
	/// Default value. This value is unused.
	FinishReasonUnspecified,
	/// Natural stop point of the model or provided stop sequence.
	Stop,
	/// The maximum number of tokens as specified in the request was reached.
	MaxTokens,
	/// The response candidate content was flagged for safety reasons.
	Safety,
	/// The response candidate content was flagged for recitation reasons.
	Recitation,
	/// The response candidate content was flagged for using an unsupported language.
	Language,
	/// Unknown reason.
	Other,
	/// Token generation stopped because the content contains forbidden terms.
	Blocklist,
	/// Token generation stopped for potentially containing prohibited content.
	ProhibitedContent,
	/// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
	Spii,
	/// The function call generated by the model is invalid.
	MalformedFunctionCall,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CitationMetadata {
	pub citation_sources: Vec<CitationSource>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct CitationSource {
	#[serde(skip_serializing_if = "Option::is_none")]
	pub uri: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub start_index: Option<i32>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub end_index: Option<i32>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub license: Option<String>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct LogprobsResult {
	pub top_candidate: Vec<TopCandidate>,
	pub chosen_candidate: Vec<LogProbCandidate>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct TopCandidate {
	pub candidates: Vec<LogProbCandidate>,
}

#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct LogProbCandidate {
	pub token: String,
	pub token_id: String,
	pub log_probability: f64,
}

/// Gemini API Configuration options for model generation and outputs. Not all parameters are
/// configurable for every model. From [Gemini API Reference](https://ai.google.dev/api/generate-content#generationconfig)
/// ### Clankers Note:
/// Can be used to construct a typesafe `additional_params` in clankers::[AgentBuilder](crate::agent::AgentBuilder).
#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct GenerationConfig {
	/// The set of character sequences (up to 5) that will stop output generation. If specified, the API will stop
	/// at the first appearance of a stop_sequence. The stop sequence will not be included as part of the response.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub stop_sequences: Option<Vec<String>>,
	/// MIME type of the generated candidate text. Supported MIME types are:
	///     - text/plain:  (default) Text output
	///     - application/json: JSON response in the response candidates.
	///     - text/x.enum: ENUM as a string response in the response candidates.
	/// Refer to the docs for a list of all supported text MIME types
	#[serde(skip_serializing_if = "Option::is_none")]
	pub response_mime_type: Option<String>,
	/// Output schema of the generated candidate text. Schemas must be a subset of the OpenAPI schema and can be
	/// objects, primitives or arrays. If set, a compatible responseMimeType must also  be set. Compatible MIME
	/// types: application/json: Schema for JSON response. Refer to the JSON text generation guide for more details.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub response_schema: Option<Schema>,
	/// Optional. The output schema of the generated response.
	/// This is an alternative to responseSchema that accepts a standard JSON Schema.
	/// If this is set, responseSchema must be omitted.
	/// Compatible MIME type: application/json.
	/// Supported properties: $id, $defs, $ref, type, properties, etc.
	#[serde(
		skip_serializing_if = "Option::is_none",
		rename = "_responseJsonSchema"
	)]
	pub _response_json_schema: Option<Value>,
	/// Internal or alternative representation for `response_json_schema`.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub response_json_schema: Option<Value>,
	/// Number of generated responses to return. Currently, this value can only be set to 1. If
	/// unset, this will default to 1.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub candidate_count: Option<i32>,
	/// The maximum number of tokens to include in a response candidate. Note: The default value varies by model, see
	/// the Model.output_token_limit attribute of the Model returned from the getModel function.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub max_output_tokens: Option<u64>,
	/// Controls the randomness of the output. Note: The default value varies by model, see the Model.temperature
	/// attribute of the Model returned from the getModel function. Values can range from [0.0, 2.0].
	#[serde(skip_serializing_if = "Option::is_none")]
	pub temperature: Option<f64>,
	/// The maximum cumulative probability of tokens to consider when sampling. The model uses combined Top-k and
	/// Top-p (nucleus) sampling. Tokens are sorted based on their assigned probabilities so that only the most
	/// likely tokens are considered. Top-k sampling directly limits the maximum number of tokens to consider, while
	/// Nucleus sampling limits the number of tokens based on the cumulative probability. Note: The default value
	/// varies by Model and is specified by theModel.top_p attribute returned from the getModel function. An empty
	/// topK attribute indicates that the model doesn't apply top-k sampling and doesn't allow setting topK on requests.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub top_p: Option<f64>,
	/// The maximum number of tokens to consider when sampling. Gemini models use Top-p (nucleus) sampling or a
	/// combination of Top-k and nucleus sampling. Top-k sampling considers the set of topK most probable tokens.
	/// Models running with nucleus sampling don't allow topK setting. Note: The default value varies by Model and is
	/// specified by theModel.top_p attribute returned from the getModel function. An empty topK attribute indicates
	/// that the model doesn't apply top-k sampling and doesn't allow setting topK on requests.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub top_k: Option<i32>,
	/// Presence penalty applied to the next token's logprobs if the token has already been seen in the response.
	/// This penalty is binary on/off and not dependent on the number of times the token is used (after the first).
	/// Use frequencyPenalty for a penalty that increases with each use. A positive penalty will discourage the use
	/// of tokens that have already been used in the response, increasing the vocabulary. A negative penalty will
	/// encourage the use of tokens that have already been used in the response, decreasing the vocabulary.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub presence_penalty: Option<f64>,
	/// Frequency penalty applied to the next token's logprobs, multiplied by the number of times each token has been
	/// seen in the response so far. A positive penalty will discourage the use of tokens that have already been
	/// used, proportional to the number of times the token has been used: The more a token is used, the more
	/// difficult it is for the  model to use that token again increasing the vocabulary of responses. Caution: A
	/// negative penalty will encourage the model to reuse tokens proportional to the number of times the token has
	/// been used. Small negative values will reduce the vocabulary of a response. Larger negative values will cause
	/// the model to  repeating a common token until it hits the maxOutputTokens limit: "...the the the the the...".
	#[serde(skip_serializing_if = "Option::is_none")]
	pub frequency_penalty: Option<f64>,
	/// If true, export the logprobs results in response.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub response_logprobs: Option<bool>,
	/// Only valid if responseLogprobs=True. This sets the number of top logprobs to return at each decoding step in
	/// [Candidate.logprobs_result].
	#[serde(skip_serializing_if = "Option::is_none")]
	pub logprobs: Option<i32>,
	/// Configuration for thinking/reasoning.
	#[serde(skip_serializing_if = "Option::is_none")]
	pub thinking_config: Option<ThinkingConfig>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub image_config: Option<ImageConfig>,
}

impl Default for GenerationConfig {
	fn default() -> Self {
		Self {
			temperature: Some(1.0),
			max_output_tokens: Some(4096),
			stop_sequences: None,
			response_mime_type: None,
			response_schema: None,
			_response_json_schema: None,
			response_json_schema: None,
			candidate_count: None,
			top_p: None,
			top_k: None,
			presence_penalty: None,
			frequency_penalty: None,
			response_logprobs: None,
			logprobs: None,
			thinking_config: None,
			image_config: None,
		}
	}
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ThinkingConfig {
	pub thinking_budget: u32,
	pub include_thoughts: Option<bool>,
}

#[derive(Debug, Deserialize, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ImageConfig {
	#[serde(skip_serializing_if = "Option::is_none")]
	pub aspect_ratio: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub image_size: Option<String>,
}

/// The Schema object allows the definition of input and output data types. These types can be objects, but also
/// primitives and arrays. Represents a select subset of an OpenAPI 3.0 schema object.
/// From [Gemini API Reference](https://ai.google.dev/api/caching#Schema)
#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct Schema {
	pub r#type: String,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub format: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub description: Option<String>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub nullable: Option<bool>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub r#enum: Option<Vec<String>>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub max_items: Option<i32>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub min_items: Option<i32>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub properties: Option<HashMap<String, Schema>>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub required: Option<Vec<String>>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub items: Option<Box<Schema>>,
}

/// Flattens a JSON schema by resolving all `$ref` references inline.
/// It takes a JSON schema that may contain `$ref` references to definitions
/// in `$defs` or `definitions` sections and returns a new schema with all references
/// resolved and inlined. This is necessary for APIs like Gemini that don't support
/// schema references.
pub fn flatten_schema(mut schema: Value) -> Result<Value, CompletionError> {
	// extracting $defs if they exist
	let defs = if let Some(obj) = schema.as_object() {
		obj.get("$defs").or_else(|| obj.get("definitions")).cloned()
	} else {
		None
	};

	let Some(defs_value) = defs else {
		return Ok(schema);
	};

	let Some(defs_obj) = defs_value.as_object() else {
		return Err(CompletionError::ResponseError(
			"$defs must be an object".into(),
		));
	};

	resolve_refs(&mut schema, defs_obj)?;

	// removing $defs from the final schema because we have inlined everything
	if let Some(obj) = schema.as_object_mut() {
		obj.remove("$defs");
		obj.remove("definitions");
	}

	Ok(schema)
}

/// Recursively resolves all `$ref` references in a JSON value by
/// replacing them with their definitions.
fn resolve_refs(
	value: &mut Value,
	defs: &serde_json::Map<String, Value>,
) -> Result<(), CompletionError> {
	match value {
		Value::Object(obj) => {
			if let Some(ref_value) = obj.get("$ref")
				&& let Some(ref_str) = ref_value.as_str()
			{
				// "#/$defs/Person" -> "Person"
				let def_name = parse_ref_path(ref_str)?;

				let def = defs.get(&def_name).ok_or_else(|| {
					CompletionError::ResponseError(format!("Reference not found: {}", ref_str))
				})?;

				let mut resolved = def.clone();
				resolve_refs(&mut resolved, defs)?;
				*value = resolved;
				return Ok(());
			}

			for (_, v) in obj.iter_mut() {
				resolve_refs(v, defs)?;
			}
		}
		Value::Array(arr) => {
			for item in arr.iter_mut() {
				resolve_refs(item, defs)?;
			}
		}
		_ => {}
	}

	Ok(())
}

/// Parses a JSON Schema `$ref` path to extract the definition name.
///
/// JSON Schema references use URI fragment syntax to point to definitions within
/// the same document. This function extracts the definition name from common
/// reference patterns used in JSON Schema.
fn parse_ref_path(ref_str: &str) -> Result<String, CompletionError> {
	if let Some(fragment) = ref_str.strip_prefix('#') {
		if let Some(name) = fragment.strip_prefix("/$defs/") {
			Ok(name.to_string())
		} else if let Some(name) = fragment.strip_prefix("/definitions/") {
			Ok(name.to_string())
		} else {
			Err(CompletionError::ResponseError(format!(
				"Unsupported reference format: {}",
				ref_str
			)))
		}
	} else {
		Err(CompletionError::ResponseError(format!(
			"Only fragment references (#/...) are supported: {}",
			ref_str
		)))
	}
}

/// Helper function to extract the type string from a JSON value.
/// Handles both direct string types and array types (returns the first element).
fn extract_type(type_value: &Value) -> Option<String> {
	if type_value.is_string() {
		type_value.as_str().map(String::from)
	} else if type_value.is_array() {
		type_value
			.as_array()
			.and_then(|arr| arr.first())
			.and_then(|v| v.as_str().map(String::from))
	} else {
		None
	}
}

/// Helper function to extract type from anyOf, oneOf, or allOf schemas.
/// Returns the type of the first non-null schema found.
fn extract_type_from_composition(composition: &Value) -> Option<String> {
	composition.as_array().and_then(|arr| {
		arr.iter().find_map(|schema| {
			if let Some(obj) = schema.as_object() {
				// Skip null types
				if let Some(type_val) = obj.get("type")
					&& let Some(type_str) = type_val.as_str()
					&& type_str == "null"
				{
					return None;
				}
				// Extract type from this schema
				obj.get("type").and_then(extract_type).or_else(|| {
					if obj.contains_key("properties") {
						Some("object".to_string())
					} else {
						None
					}
				})
			} else {
				None
			}
		})
	})
}

/// Helper function to extract the first non-null schema from anyOf, oneOf, or allOf.
/// Returns the schema object that should be used for properties, required, etc.
fn extract_schema_from_composition(composition: &Value) -> Option<serde_json::Map<String, Value>> {
	composition.as_array().and_then(|arr| {
		arr.iter().find_map(|schema| {
			if let Some(obj) = schema.as_object()
				&& let Some(type_val) = obj.get("type")
				&& let Some(type_str) = type_val.as_str()
			{
				if type_str == "null" {
					return None;
				}
				Some(obj.clone())
			} else {
				None
			}
		})
	})
}

/// Helper function to infer the type of a schema object.
/// Checks for explicit type, then anyOf/oneOf/allOf, then infers from properties.
fn infer_type(obj: &serde_json::Map<String, Value>) -> String {
	// First, try direct type field
	if let Some(type_val) = obj.get("type")
		&& let Some(type_str) = extract_type(type_val)
	{
		return type_str;
	}

	// Then try anyOf, oneOf, allOf (in that order)
	if let Some(any_of) = obj.get("anyOf")
		&& let Some(type_str) = extract_type_from_composition(any_of)
	{
		return type_str;
	}

	if let Some(one_of) = obj.get("oneOf")
		&& let Some(type_str) = extract_type_from_composition(one_of)
	{
		return type_str;
	}

	if let Some(all_of) = obj.get("allOf")
		&& let Some(type_str) = extract_type_from_composition(all_of)
	{
		return type_str;
	}

	// Finally, infer object type if properties are present
	if obj.contains_key("properties") {
		"object".to_string()
	} else {
		String::new()
	}
}

impl TryFrom<Value> for Schema {
	type Error = CompletionError;

	fn try_from(value: Value) -> Result<Self, Self::Error> {
		let flattened_val = flatten_schema(value)?;
		if let Some(obj) = flattened_val.as_object() {
			// Determine which object to use for extracting properties and required fields.
			// If this object has anyOf/oneOf/allOf, we need to extract properties from the composition.
			let props_source = if obj.get("properties").is_none() {
				if let Some(any_of) = obj.get("anyOf") {
					extract_schema_from_composition(any_of)
				} else if let Some(one_of) = obj.get("oneOf") {
					extract_schema_from_composition(one_of)
				} else if let Some(all_of) = obj.get("allOf") {
					extract_schema_from_composition(all_of)
				} else {
					None
				}
				.unwrap_or(obj.clone())
			} else {
				obj.clone()
			};

			Ok(Schema {
				r#type: infer_type(obj),
				format: obj.get("format").and_then(|v| v.as_str()).map(String::from),
				description: obj
					.get("description")
					.and_then(|v| v.as_str())
					.map(String::from),
				nullable: obj.get("nullable").and_then(|v| v.as_bool()),
				r#enum: obj.get("enum").and_then(|v| v.as_array()).map(|arr| {
					arr.iter()
						.filter_map(|v| v.as_str().map(String::from))
						.collect()
				}),
				max_items: obj
					.get("maxItems")
					.and_then(|v| v.as_i64())
					.map(|v| v as i32),
				min_items: obj
					.get("minItems")
					.and_then(|v| v.as_i64())
					.map(|v| v as i32),
				properties: props_source
					.get("properties")
					.and_then(|v| v.as_object())
					.map(|map| {
						map.iter()
							.filter_map(|(k, v)| {
								v.clone().try_into().ok().map(|schema| (k.clone(), schema))
							})
							.collect()
					}),
				required: props_source
					.get("required")
					.and_then(|v| v.as_array())
					.map(|arr| {
						arr.iter()
							.filter_map(|v| v.as_str().map(String::from))
							.collect()
					}),
				items: obj
					.get("items")
					.and_then(|v| v.clone().try_into().ok())
					.map(Box::new),
			})
		} else {
			Err(CompletionError::ResponseError(
				"Expected a JSON object for Schema".into(),
			))
		}
	}
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct GenerateContentRequest {
	pub contents: Vec<Content>,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub tools: Option<Vec<Tool>>,
	pub tool_config: Option<ToolConfig>,
	/// Optional. Configuration options for model generation and outputs.
	pub generation_config: Option<GenerationConfig>,
	/// Optional. A list of unique SafetySetting instances for blocking unsafe content. This will be enforced on the
	/// [GenerateContentRequest.contents] and [GenerateContentResponse.candidates]. There should not be more than one
	/// setting for each SafetyCategory type. The API will block any contents and responses that fail to meet the
	/// thresholds set by these settings. This list overrides the default settings for each SafetyCategory specified
	/// in the safetySettings. If there is no SafetySetting for a given SafetyCategory provided in the list, the API
	/// will use the default safety setting for that category. Harm categories:
	///     - HARM_CATEGORY_HATE_SPEECH,
	///     - HARM_CATEGORY_SEXUALLY_EXPLICIT
	///     - HARM_CATEGORY_DANGEROUS_CONTENT
	///     - HARM_CATEGORY_HARASSMENT
	/// are supported.
	/// Refer to the guide for detailed information on available safety settings. Also refer to the Safety guidance
	/// to learn how to incorporate safety considerations in your AI applications.
	pub safety_settings: Option<Vec<SafetySetting>>,
	/// Optional. Developer set system instruction(s). Currently, text only.
	/// From [Gemini API Reference](https://ai.google.dev/gemini-api/docs/system-instructions?lang=rest)
	pub system_instruction: Option<Content>,
	// cachedContent: Optional<String>
	/// Additional parameters.
	#[serde(flatten, skip_serializing_if = "Option::is_none")]
	pub additional_params: Option<serde_json::Value>,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Tool {
	pub function_declarations: Vec<FunctionDeclaration>,
	pub code_execution: Option<CodeExecution>,
}

#[derive(Debug, Serialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct FunctionDeclaration {
	pub name: String,
	pub description: String,
	#[serde(skip_serializing_if = "Option::is_none")]
	pub parameters: Option<Schema>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ToolConfig {
	pub function_calling_config: Option<FunctionCallingMode>,
}

#[derive(Debug, Serialize, Deserialize, Default)]
#[serde(tag = "mode", rename_all = "UPPERCASE")]
pub enum FunctionCallingMode {
	#[default]
	Auto,
	None,
	Any {
		#[serde(skip_serializing_if = "Option::is_none")]
		allowed_function_names: Option<Vec<String>>,
	},
}

impl TryFrom<message::ToolChoice> for FunctionCallingMode {
	type Error = CompletionError;
	fn try_from(value: message::ToolChoice) -> Result<Self, Self::Error> {
		let res = match value {
			message::ToolChoice::Auto => Self::Auto,
			message::ToolChoice::None => Self::None,
			message::ToolChoice::Required => Self::Any {
				allowed_function_names: None,
			},
			message::ToolChoice::Specific { function_names } => Self::Any {
				allowed_function_names: Some(function_names),
			},
		};

		Ok(res)
	}
}

#[derive(Debug, Serialize)]
pub struct CodeExecution {}

#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SafetySetting {
	pub category: HarmCategory,
	pub threshold: HarmBlockThreshold,
}

#[derive(Debug, Serialize)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum HarmBlockThreshold {
	HarmBlockThresholdUnspecified,
	BlockLowAndAbove,
	BlockMediumAndAbove,
	BlockOnlyHigh,
	BlockNone,
	Off,
}
